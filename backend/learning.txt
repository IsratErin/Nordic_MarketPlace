# Common examples of API errors
Type	Example	Status Code
Client errors (4xx)	Invalid input, missing parameters	400 Bad Request
	Unauthorized access	401 Unauthorized
	Forbidden resource	403 Forbidden
	Resource not found	404 Not Found
Server errors (5xx)	Unexpected database error	500 Internal Server Error
	Third-party API fails	502 Bad Gateway / 503 Service Unavailable

#Here’s a concise summary of the benefits of using error middleware:  (Seperation of Concerns in robust System Design)
-Centralized error handling – All errors (Zod, Prisma, custom) are handled in one place. 
-Consistent responses – Returns uniform JSON structure for all errors.
-Clean controllers – Controllers stay thin; no repeated res.status(...).json(...) logic, only focus on business logic
-Supports multiple error types – Validation, database, authentication, and custom errors.
-Easier maintenance & scaling – Adding new routes or services doesn’t require rewriting error logic.
-Production-ready – Simplifies logging, monitoring, and debugging.
-AWS / container friendly – Works well in distributed or serverless environments.
-Middleware (errorMiddleware.ts) handles the mapping from internal errors to user-friendly API responses about the errors.

#Prisma and TypeScript are strict with optional fields
When exactOptionalPropertyTypes is enabled, TypeScript treats these differently:
string | null
string | undefined
These are not interchangeable.
If a type expects string | null, you MUST NOT pass undefined.
Zod .optional() produces undefined. Use .transform() to convert undefined → null

Why string().optional() fails with reading null data from database? : optional() means:
allowed: string, undefined
NOT allowed: null
The transform runs after validation.
So it never reaches .transform((v) => v ?? null) because validation already failed. So solution is .nullable() before .optional()

#Zod ensures and adds runtime validation, so that data really matches TypeScript types.
Required fields are present, Types match (string, number, boolean, etc.), Input isn’t malformed or dangerous
Without validation, bad data could: Crash the server, Corrupt the database, Create vulnerabilities

# When using exactOptionalPropertyTypes: true in TypeScript,
- we must filter out undefined values from partial update info objects before passing them to Prisma.
- because Zod's .partial() creates T | undefined types, and prisma doesn’t acceppt poperties as undefined.


###########____Testing_____#######

#UNIT TESTING CHECKLIST (Best Practice)

-Test only ONE thing at a time:
Test business logic, One function at a time
Don’t test routes, Don’t test database

- Do Not use real database
Never connect to Prisma DB in unit tests, Always mock Prisma
Why? -- Tests stay fast, Tests don’t break because of DB issues

-Clear test structure:
Use this pattern in every test: Arrange → Act → Assert
Arrange → prepare data & mocks
Act → call the function
Assert → check result

-Test success AND failure:
Always test: Valid input, Invalid input, ### Edge cases (empty, null, undefined)

-No shared state between tests:
Tests should not depend on each other, ## Reset mocks after each test

## "ESM" UNIT TEST CHECKLIST :Before every project:
"type": "module" in package.json
Jest config uses default-esm
.js extensions in imports
No real DB connections
**Mocks declared and implented before importing the modules from their relative folders
#jest.unstable_mockModule is Required for ESM (not jest.mock()) and Without this, Prisma is imported before being mocked
- need await before imports to Ensure the mock is registered before module evaluation
- need Dynamic import() to guarantee that  we receive the mocked Prisma client. Static imports would lock in the real implementation
- jest.fn() inside the factory to ensure .mockResolvedValue() exists at runtime as Casting alone is not enough
- type never error solved by using unknown as jest.MockedFunction
 
